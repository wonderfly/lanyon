---
layout: post
title: UTLK - CHAPTER 1 Introduction
---

# Kernel Architecture
Monolithic v.s. microkernels. Like most Unix kernels, Linux is monolithic:
single binary in one address space. The major advantage a monolithic kernel has
over a microkernel is performance, because there aren't many inter-process
messaging as the latter has. That said, microkernels have a few legitimate pros
on its own:

  - Modularized design. Many kernel components are broken down to smaller
    binaries and inter-process communication requires well designed interfaces
  - Portability. Because the platform dependant portion is stripped down to a
    minimal (only the main kernel), it's easier to port a microkernel to a
different platform
  - Better memory performance. Unneeded kernel code isn't loaded into memory,
    unlike a monolithic one which is always mapped at its entirety.

To achieve some of the above advantages, Linux offers _modules_:

  - Modules force good modular design. Interface between a module and the main
    kernel should be well designed.
  - Platform independence.
  - Frugal memory usage. Tiny systems like embedded devices can choose to not
    load all modules.
  - No performance penalty. Loading and unloading a module is much cheaper than
    creating and destroying a process like in the microkernel model.

# An Overview of the Unix Filesystem
At the heart of the Unix operating system is its file system.

## Files and Directories
A file is a sequence of bytes. A file system is a user level abstraction of the
data stored on physical devices like a hard disk, because user processes don't
interact with devices directly.

A directory contains information about the files and directories beneath it.

## Hard and Soft Links
A file can have multiple names, in the form of _links_. A file is only deleted
when its number of links decreases to zero. Links have two major limitations:

  - Links to directories are not allowed. This is to prevent cycles the
    directory tree.
  - Links can not cross filesystems. There might be multiple of them mounted at
    the same time, for example from two hard drives, or two partitions on the
same drive.

To mitigate those limitations, there exist _soft links_. They are called so to
distinguish from the regular links. Soft links can be created for directories,
and can cross file system boundaries. To create a soft link:

```shell
ln -s <target> <link>
```

## File Types
  - Regular files, directories, symlinks
  - Block device files, character device files, pipes, sockets

## File Descriptor and Inode
Unix distinguishes between the _contents_ of a file, and the _metadata_ of a
file. The former is purely a sequence of bytes, while the latter is a data
structure that holds information like creation time, owner, access rights, etc.
The latter is often called the _inode_. Each file has its own inode.

## Access Rights and File Mode
Owner, group, other, read, write, execute, suid, sgid, sticky.
_Note_: the "sticky" bit on an executable tells the kernel not to release its
code block from memory even when the process that executes it has terminated. It
has been deprecated.

## File-Handling System Calls
### Opening a file
```C
  fd = open(path, flag, mode)
```

The return value, `fd`, is the File Descriptor, which is an index to an _open
file object_, which contains information about the current read offset (file
pointer), pointers to kernel functions that the process can invoke, and etc.

### Accessing an opened file
`read`, `lseek`.

### Closing a file
`close`.

### Renaming and deleting a file
These operations are actually on the directory that the file is in. To delete a
file, use `unlink(pathname)`. As can be tell from the function name, this
decreases the link of the file by one. It won't be deleted until the link number
drops to zero.

# An Overview of Unix Kernels
A quick overview of almost all aspects of a Unix kernel.

## The Process/Kernel Model
CPUs have multiple execution states, two of them are "Kernel Mode" and "User
Mode". In Unix, user processes run in "User Mode", while kernel threads run in
"Kernel Mode". In the majority of time, some user process is running on the CPU
while the kernel is largely asleep, except for a few lightweight "kernel
threads". There are a few cases where the main kernel body will be run:

  - When a user process explicitly requests the kernel through a _system call_.
  - When some _exception_ happens while executing a user process, e.g., page
    fault.
  - When a hardware device _interrupts_ the CPU through a signal.

## Process Implementation
The kernel isn't a process, but a process manager. The implementation of a
process involes the "pause" and "resume" of one. To pause a running process, its
states are dumped into a data structure, the _process descriptor_. To resume,
the kernel loads the CPU with those states, thus the process can continue
running like it never stopped. The information that is dumped and loaded
include:

  - The program counter (PC) and stack pointer (SP) registers
  - The general purpose registers
  - The floating point registers
  - The memory management registers used to keep track of memory accessed by the
    process
  - ...

## Reentrant Kernels
All Unix kernels are reentrant. This means a kernel execution path can be
suspended, while another takes over the CPU, and then resumed when the latter
finishes.

## Process Address Space
Every process runs in its private address space. When switched into kernel mode,
it runs in its private kernel address space.

There are a couple of exceptions where the same memory region may be shared
among processes:

  - A commonly used program's code section is loaded into memory and shared
    among all processes that use it. Examples are editors, and shared libraries.
When this happens it is usually done automatically by the kernel without the
user noticing.
  - Two user processes could explicitly request that a region of memory to be
    shared. This is enabled for Inter-Process Communication (IPC), and is
usually refered to as "shared memory".

  - User processes could use the `mmap()` system call to map a file, or a block
    device (essentially also a file) into its address space. This is usually to
facilitate data read or write. The mapped file can be shared with other
processes.
